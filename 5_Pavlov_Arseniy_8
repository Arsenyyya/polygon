#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <cassert>
#include <limits>
#include <cmath>
#include <fstream>
#include <sstream>
#include <chrono>
#include <algorithm>
// все инклюды по O(1) памяти
// далее местами буду писать на английском, т.к. переключать раскладку долго, прошу простить
using namespace std; //O(1) memory
using namespace chrono; //O(1) memory

using Graph = map<int, vector<pair<int, double>>>; //O(V+E) memory; O(log(V)) для вставок, удаления и поиска по ключу
using Coordinates = map<int, pair<double, double>>; //O(V) память; O(log(V)) для вставок, удаления и поиска по ключу

void parseGraph(const string& filename, Graph& graph, Coordinates& coordinates) {
    ifstream file(filename); //O(1) memory; O(1) difficulty
    if (!file.is_open()) { //diff: O(1)
        cerr << "Error opening file: " << filename << endl;//O(1) both
        return; //O(1) difficulty
    }

    map<pair<double, double>, int> coordinateToId; memory: //создание строки O(k), k = len(str); difficulty O(n*k) - the worst(n - number of str in file)
    int nodeId = 0; //O(1) both

    auto getId = [&](double lon, double lat) { //O(1) both
        pair<double, double> coord = {lon, lat}; //O(1) both (fix value for both of double)
        if (!coordinateToId.count(coord)) { difficulty: //O(log(N))
            coordinateToId[coord] = nodeId; //mem: O(1), diff: O(log(V))
            coordinates[nodeId] = coord; //mem: O(1), diff: O(log(N))
            return nodeId++; //time: O(1)
        }
        return coordinateToId[coord]; //time: O(log(N))
    };

    string line; //both O(1)
    while (getline(file, line)) { //diff: O(n)
        size_t colon = line.find(":"); //mem: O(1); diff: O(k)
        if (colon == string::npos) continue; //diff: O(1)

        string parentNode = line.substr(0, colon); //both O(m), m - len of included str
        string children = line.substr(colon + 1); //same as previous

        double lon1, lat1; //both O(1)
        sscanf(parentNode.c_str(), "%lf,%lf", &lon1, &lat1); //time O(1)
        int parentId = getId(lon1, lat1); //mem: O(1), diff: O(n*V) the worst and O(log(n)) median

        stringstream ss(children); //mem: O(n), diff: O(1)
        string child; // both O(1)
        while (getline(ss, child, ';')) { //mem: O(k); diif: O(n), where's k = len(str), n = len of included str
            double lon2, lat2, weight; //both O(1)
            if (sscanf(child.c_str(), "%lf,%lf,%lf", &lon2, &lat2, &weight) == 3) { //time: O(1)
                int childId = getId(lon2, lat2); //mem: O(1); diff: O(log(N)+Log(V))
                graph[parentId].emplace_back(childId, weight); //both O(1)
                graph[childId].emplace_back(parentId, weight); //same
            }
        }
    }
}


int findNearestNode(const Coordinates& coordinates, double lon, double lat) {
    int nearestNode = -1; // both O(1)
    double minDistance = numeric_limits<double>::infinity(); //same

    for (const auto& [node, coord] : coordinates) { //O(V)
        double distance = sqrt(pow(coord.first - lon, 2) + pow(coord.second - lat, 2)); //Both O(1)
        if (distance < minDistance) { //time: O(1)
            minDistance = distance; //same
            nearestNode = node; //same
        }
    }
    return nearestNode; //same
}

// double weight(const map<int, int>& parent, int start, int goal, const Graph& graph) {
//     vector<int> path;
//     double weight = 0;
//     for (int cur = goal; cur != start; cur = parent.at(cur)) {
//         path.push_back(cur);
//         for (const auto& [neighbor, w] : graph.at(parent.at(cur)))
//             if (neighbor == cur) weight += w;
//     }
//     path.push_back(start);
//     reverse(path.begin(), path.end());
//     return weight;
// }

double printPath(const map<int, int>& parent, int start, int goal, const Graph& graph) {
    vector<int> path; //both O(1)
    double weight = 0; //same
    for (int cur = goal; cur != start; cur = parent.at(cur)) { //time: O(V)
        path.push_back(cur); //diff: O(N) worst
        for (const auto& [neighbor, w] : graph.at(parent.at(cur))) //diff: O(Ev), where's Ev - number of edges from one node
            if (neighbor == cur) weight += w; //diff: O(1)
    }
    path.push_back(start); //diff: O(1)

    reverse(path.begin(), path.end()); //diff: O(p), wheres p - length of path
    cout << "\nTotal weight: " << weight << endl; //time: O(1)
    return weight; //same
}

double DFS(const Graph& graph, int start, int goal) {
    auto start_time = high_resolution_clock::now();

    stack<int> s; //both O(1)
    set<int> visited; //same
    map<int, int> parent; //same
    s.push(start); //same

    while (!s.empty()) { //diff: O(V) the worst
        int current = s.top(); //both O(1)
        s.pop(); //diff: O(1)

        if (visited.count(current)) continue; //diff: O(log(V))
        visited.insert(current); //mem: O(Log(V)) the worst; diff: O(log(V))

        if (current == goal) { //diff:O(1)
            auto end_time = high_resolution_clock::now(); //both O(1)
            printPath(parent, start, goal, graph); //mem: O(V); diff: O(V*Ev)
            cout << "DFS Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n"; //time: O(1)
            return printPath(parent, start, goal, graph); //mem: O(V); diff: O(V*Ev)
        }

        for (const auto& [neighbor, _] : graph.at(current)) { //diff: O(V*Ev)
            if (!visited.count(neighbor)) { //O(log(V))
                s.push(neighbor); //both O(1)
                parent[neighbor] = current;//mem: O(1); diff: O(log(V))
            }
        }
    }
    cout << "DFS: No path found.\n"; //both O(1)
}

double BFS(const Graph& graph, int start, int goal) { //Totally same as DFS
    auto start_time = high_resolution_clock::now();

    queue<int> q;
    set<int> visited;
    map<int, int> parent;
    q.push(start);

    while (!q.empty()) {
        int current = q.front();
        q.pop();

        if (visited.count(current)) continue;
        visited.insert(current);

        if (current == goal) {
            auto end_time = high_resolution_clock::now();
            printPath(parent, start, goal, graph);
            cout << "BFS Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n";
            return printPath(parent, start, goal, graph);
        }

        for (const auto& [neighbor, _] : graph.at(current)) {
            if (!visited.count(neighbor)) {
                q.push(neighbor);
                parent[neighbor] = current;
            }
        }
    }
    cout << "BFS: No path found.\n";
}

double Dijkstra(const Graph& graph, int start, int goal) {
    auto start_time = high_resolution_clock::now(); //both O(1)

    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq; //same
    map<int, double> distances; //same
    map<int, int> parent; //same

    for (const auto& node : graph) distances[node.first] = numeric_limits<double>::infinity(); //diff: O(V)*O(Log(V))=O(V*log(V))
    distances[start] = 0; //diff: O(LOg(V)

    pq.emplace(0, start); //mem:O(1); diff:O(log(V))

    while (!pq.empty()) { //diif: O(N*V) the worst
        auto [current_distance, current_node] = pq.top(); //diff:O(1)
        pq.pop(); //diff: LOG(V)

        if (current_node == goal) { //time: O(1)
            auto end_time = high_resolution_clock::now(); //same
            printPath(parent, start, goal, graph); //mem:O(V); diff: O(V*Ev)
            cout << "Dijkstra Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n"; //time: O(1)
            return printPath(parent, start, goal, graph);
        }

        for (const auto& [neighbor, weight] : graph.at(current_node)) { //diff: O(Ev)
            double new_distance = current_distance + weight; //both O(1)

            if (new_distance < distances[neighbor]) { //diff: O(1)
                distances[neighbor] = new_distance; //diff: O(log(V))
                parent[neighbor] = current_node; //same
                pq.emplace(new_distance, neighbor); //mem: O(1); diff: O(log(V))
            }
        }
    }
    cout << "Dijkstra: No path found.\n"; //both O(1)
}

double AStar(const Graph& graph, int start, int goal, const Coordinates& coordinates) {
    auto start_time = high_resolution_clock::now(); //both O91)

    auto heuristic = [&](int node) {
        auto [lon1, lat1] = coordinates.at(node); //diff: O(log(V))
        auto [lon2, lat2] = coordinates.at(goal); //same
        return sqrt((lon1 - lon2) * (lon1 - lon2) + (lat1 - lat2) * (lat1 - lat2)); //both O91)
    };

    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq; //same
    map<int, double> g_costs; //same
    map<int, double> f_costs;//same
    map<int, int> parent; //same

    for (const auto& node : graph) { //diff: O(V)
        g_costs[node.first] = numeric_limits<double>::infinity(); //diff O(LogV))
        f_costs[node.first] = numeric_limits<double>::infinity(); //same
    }//O(V*Log(V)) totall
    g_costs[start] = 0; //diff O(LogV))
    f_costs[start] = heuristic(start); //same

    pq.emplace(f_costs[start], start); //mem: O(1); diff: O(log(V))

    while (!pq.empty()) { //diff: O(N*V) the worst
        auto [current_f_cost, current_node] = pq.top(); //diff: O(1)
        pq.pop(); //diff: O(log(V))

        if (current_node == goal) { //diff: O(1)
            auto end_time = high_resolution_clock::now(); //both O(1)
            printPath(parent, start, goal, graph); //mem: O(V); diff: O(V*Ev)
            cout << "A* Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n"; //diff: O(1)
            return printPath(parent, start, goal, graph); //mem: O(V); Diff: O(V*Ev)
        }

        for (const auto& [neighbor, weight] : graph.at(current_node)) { //Diff: O(V*Ev)
            double tentative_g_cost = g_costs[current_node] + weight; //both O(1)

            if (tentative_g_cost < g_costs[neighbor]) { //diff(1)
                g_costs[neighbor] = tentative_g_cost; //diff O(log(V))
                f_costs[neighbor] = tentative_g_cost + heuristic(neighbor); //same
                parent[neighbor] = current_node; //sa,e
                pq.emplace(f_costs[neighbor], neighbor); //same
            }
        }
    }
    cout << "A*: No path found.\n"; //both O(1)
}
//
// void test_a_star() {
//     Graph graph;
//     Coordinates coordinates;
//     parseGraph("test_graph.txt", graph, coordinates);
//     double startLon = 1.0, startLat = 1.0;
//     double goalLon= 2.0, goalLat = 2.0;
//     int start = findNearestNode(coordinates, startLon, startLat);
//     int goal = findNearestNode(coordinates, goalLon, goalLat);
//     assert()
//
// }

void test_dfs() {
    Graph graph;
    Coordinates coordinates;
    parseGraph("test_graph.txt", graph, coordinates);
    double startLon = 1.0, startLat = 1.0;
    double goalLon= 2.0, goalLat = 2.0;
    int start = findNearestNode(coordinates, startLon, startLat);
    int goal = findNearestNode(coordinates, goalLon, goalLat);
    double weight_dfs = DFS(graph, start, goal);
    assert(weight_dfs == 74.0);
}

void test_bfs() {
    Graph graph;
    Coordinates coordinates;
    parseGraph("test_graph.txt", graph, coordinates);
    double startLon = 1.0, startLat = 1.0;
    double goalLon= 2.0, goalLat = 2.0;
    int start = findNearestNode(coordinates, startLon, startLat);
    int goal = findNearestNode(coordinates, goalLon, goalLat);
    double weight_bfs = BFS(graph, start, goal);
    assert(weight_bfs == 22.0);
}

void test_dijkstra() {
    Graph graph;
    Coordinates coordinates;
    parseGraph("test_graph.txt", graph, coordinates);
    double startLon = 1.0, startLat = 1.0;
    double goalLon= 2.0, goalLat = 2.0;
    int start = findNearestNode(coordinates, startLon, startLat);
    int goal = findNearestNode(coordinates, goalLon, goalLat);
    double weight_deijkstra = Dijkstra(graph, start, goal);
    assert(weight_deijkstra == 18.0);
}

void test_Astar() {
    Graph graph;
    Coordinates coordinates;
    parseGraph("test_graph.txt", graph, coordinates);
    double startLon = 1.0, startLat = 1.0;
    double goalLon= 2.0, goalLat = 2.0;
    int start = findNearestNode(coordinates, startLon, startLat);
    int goal = findNearestNode(coordinates, goalLon, goalLat);
    double weight_deijkstra = Dijkstra(graph, start, goal);
    assert(weight_deijkstra == 18.0);
}

int main() {
    string filename = "spb_graph.txt";
    test_dfs();
    test_bfs();
    test_dijkstra();
    test_Astar();
    cout << "All tests passed.\n";

    Graph graph;
    Coordinates coordinates;
    parseGraph(filename, graph, coordinates);

    double startLon = 30.499879, startLat = 59.936492 ;
    double goalLon= 30.307961, goalLat = 59.957246;


    int start = findNearestNode(coordinates, startLon, startLat);
    int goal = findNearestNode(coordinates, goalLon, goalLat);

    if (start == -1 || goal == -1) {
        cerr << "Error: Start or goal node not found by coordinates." << endl;
        return 1;
    }

    cout << "\nRunning DFS:\n";
    DFS(graph, start, goal);

    cout << "\nRunning BFS:\n";
    DFS(graph, start, goal);

    cout << "\nRunning Dijkstra:\n";
    Dijkstra(graph, start, goal);

    cout << "\nRunning A*:\n";
    AStar(graph, start, goal, coordinates);

    return 0;
}
